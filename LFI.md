요청 경로 `/npm-pwg/..;/axis2-AWC/services/listServices`는 **명백한 공격 시도**이며, 두 가지 주요 기법이 결합된 것입니다:

---

## 🚨 1. 디렉터리 트래버설 우회 시도 (`..;`)

* `..;/`는 **디렉터리 상위 이동 시도를 우회하기 위한 기법**입니다.
* 보통 `../`는 필터링되지만, `..;`처럼 **세미콜론(;)을 끼워넣는 방식**으로 필터를 우회하려는 것입니다.
* 서버 또는 웹 애플리케이션이 세미콜론 이후를 무시하고 처리하면, 실제로 `../axis2-AWC/services/listServices`처럼 처리될 수 있습니다.

---

당신이 제시한 URL 경로:

```
/render/public/..%252f%255Cd26vk7hkvaoc75aqc1k01rpyo3cok4k7q.oast.me%252f%253F%252f..%252f..
```

는 **이중 인코딩(double‑encoded path‑traversal) + OAST out‑of‑band callback**을 결합한 매우 고급 공격 시도로 보입니다.
아래는 구성 요소별 자세한 분석입니다.

---

### 🔍 경로의 주요 구조

1. **`..%252f` → `..%2f` → `../`**

   * `%252f`는 `%2f`(**/**)를 이중 인코딩한 형태입니다. 즉, 두 번 디코딩하면 실제 `"../"`가 됩니다.
   * 이 방식은 WAF가 `../` 필터링을 우회하도록 고안됐습니다 ([unsafe.sh][1], [GitHub][2]).

2. **`%255C` → `%5C` → `\`**

   * `%255C`는 `\`의 URL 인코딩(`%5C`)을 이중으로 인코딩한 경우입니다.
   * 일부 경로 처리 로직은 백슬래시(`\`)를 상위/하위 경로 구분 또는 우회 용도로 잘못 해석할 수 있으며, 이 역시 경로 변조에 사용될 수 있습니다.

3. **`d26vk7hkvaoc75aqc1k01rpyo3cok4k7q.oast.me`**

   * `*.oast.me` 도메인은 일반적인 사용자와 통신하는 서버(예: 로컬 웹 애플리케이션)가 URL을 통해 **외부 HTTP 호출** 또는 **DNS 해결**을 시도할 때, 공격자에게 알림을 보내기 위해 자동으로 생성되는 **OAST / Interact.sh out-of-band 콜백 도메인**입니다 ([Reddit][3]).

---

### 🧠 공격 의도 분석

* 공격자는 **`../` 디렉터리 트래버설**을 이중 인코딩으로 우회하여 `/render/public/`의 외부 호스트(= `oast.me`) URL 부분을 경로 안에 삽입하려고 합니다.
* 만약 `/render/public/…` 내부 처리가 Java 템플릿에 포함되어 `File` 객체, `URL` 객체, 또는 SSRF/토템 플레이스홀더 등으로 변환되면, 서버가 **`oast.me` 도메인에 POST/GET/DNS 요청**을 시도하게 됩니다.
* 이렇게 되면 공격자는 “서버가 실제로 외부로 요청했는지” 여부를 알 수 있고, 이를 통해 **blind SSRF / server-side callback** 성공을 감지할 수 있습니다.

---

### 🎯 요약표

| 항목            | 설명                                              |
| ------------- | ----------------------------------------------- |
| `..%252f...`  | 이중 인코딩된 `../` (디렉터리 트래버설 우회 시도)                 |
| `%255C`       | 백슬래시 사용한 경로 우회 / 플랫폼 의존 경로 조작                   |
| `oast.me` 도메인 | 공격자가 제어하는 OAST 도메인, 외부 요청 유도 → blind SSRF 여부 탐지 |
| 전체 목적         | WAF 우회 + 내부 템플릿 또는 파일 핸들러에 SSRF/URL 호출 유도       |

---

### ⚠️ 주요 위험

* **SSRF 가능성**

  * 서버가 `java.net.URL`, `FileInputStream`, `HttpURLConnection`, template placeholder 등과 같이 경로에 있는 URL을 실제 호출할 경우, 공격자의 OAST 서버로 요청이 전송됩니다.
  * DNS 레코드, HTTP GET, POST 요청까지 포함하여 다양한 방식으로 요청 유무가 수집될 수 있습니다.

* **경로 오염 / 정보 유출**

  * 디렉터리 트래버설이 작동할 경우, 로컬 환경 정보가 노출될 수도 있습니다.

* **WAF 필터링 우회**

  * `../`나 `\`를 둘러싼 filtering이 제대로 설계되지 않았다면, 단순한 필터링으로는 방어가 어렵습니다.

---

### ✅ 보안 권고 및 대응 방안

1. **WAF / 웹 서버에서 이중 인코딩 제거 + `../`, `%2e`, `%5B`, `%5C` 를 포함한 경로 차단 규칙 강화**

   * 예: `/render/` 이후 `/%25|%5C/` 또는 `\x2e\x2e` 등의 비표준 입력까지 처리하도록 정책 강화하십시오.

2. **경로 정규화 처리 전 필터링 적용**

   * 이중 인코딩된 문자열이 해제된 후 최종 `../`가 남는 경우에도 감지할 수 있도록 다단계 정규화를 적용하세요 ([raingray.com][4], [Medium][5]).

3. **OAST / Interact.sh 도메인 요청 탐지 규칙 포함**

   * 로그 또는 SIEM에 `*.oast.me`, `projectdiscovery.io`, `*.burpcollaborator.net` 등을 검색하는 탐지 룰을 설정해두세요 ([cloud.tencent.com][6]).

   예시 (Elasticsearch / Splunk SCM 룰):

   ```
   Domain: /\.oast\./ OR :.oastify\.com/ OR projectdiscovery\.io
   ```

4. **애플리케이션 템플릿/URL-handling 로직 검토**

   * 경로를 생성할 때 외부 리소스를 참조하지 않도록, 또는 URL fetch 이전에 도메인 화이트리스트 확인 절차를 넣으세요.
   * 경로 조작을 막기 위해, Java `URI.normalize()` 또는 `Paths.get(...).normalize()`를 사용하여 실제 파일 시스템 경로로 변환하기 전 검증 코드를 강화해야 합니다.

5. **로그 모니터링 및 IP 차단**

   * `/render/public/` 요청 내에 `/%25` 또는 `oast.me` 등이 포함된 요청 IP를 식별하여, 반복 시 차단 또는 알림 칸으로 격리하세요.

6. **표준 최신 취약점 대응 프레임워크 적용**

   * OWASP pattern filtering, Nginx `denyuri`, Lustre safe-browsing filter, reavor-phase filtering 등을 고려하십시오.

---

### 🎥 유사 사례 및 참고 인사이트

> “*.oast.*” OR “projectdiscovery.io” OR “\*.oastify.com”는 핑백 도메인 탐지 시 사용되는 보안 룰입니다. ([Reddit][7])
>
> “... 필터가 아직 `%2f`나 `%255c` 등 이중 인코딩된 문자열을 해제하지 못하거나, 순회 필터가 한 번만 적용되어 우회당할 수 있다.” ([Medium][5])

---

### 🧾 결론

* 이 요청은 단순 디렉터리 트래버설 시도를 넘어서 **서버가 실제로 외부 도메인에 연결을 시도할지 탐지하려는 매우 정교한 공격**입니다.
* **서버가 `*.oast.me`로 응답하거나 DNS 조회를 하는지 반드시 확인**해야 합니다.
* 즉각적으로 **path normalization 및 이중 인코딩 우회 방지를 위한 보안 강화**, **OAST 도메인 요청 탐지**, **WAF 규칙 보완**이 필요합니다.
