## 🐈‍⬛ Blind SQL Injection


#### 🔹 1:

* **탐지된 패턴**:
  `3 SELECT Statement Keywords found within: 22' and (select 1 from(select count(*),concat(...`
* **의미**:

  * 이 규칙은 **한 쿼리 내에서 SELECT가 여러 번 중첩되어 사용된 경우**를 감지합니다.
  * 특히 `CONCAT`와 함께 사용되어, **오류 메시지를 통해 내부 정보를 노출**시키려는 시도를 탐지합니다.
    

* 예시 쿼리:
  
  ```sql
  ' AND (SELECT 1 FROM (SELECT COUNT(*), CONCAT('c4c...', FLOOR(RAND()*2)) x FROM information_schema.tables GROUP BY x) a) -- 
  ```
* 이 쿼리는 주로 다음 목적을 위해 사용됩니다:

  1. **중첩된 SELECT**를 이용해 DB 동작을 복잡하게 만들고
  2. `CONCAT`으로 특정 문자열을 조합하여 응답에 노출시키고
  3. 결과가 에러를 유발하게 하여, **오류 메시지를 통해 내부 정보를 유출**하려는 것입니다.

---

#### 🔹 2:

* **탐지된 패턴**:
  `SELECT 1 FROM(SELECT COUNT(*),CONCAT('c4ca4238a0b923820dcc509a6f75849b',...`
* **의미**:

  * `CONCAT`, `COUNT`, `RAND` 등 **MySQL 내장 함수**들을 활용한 **정보 유출 시도**를 감지합니다.
  * `c4ca4238a0b923820dcc509a6f75849b` 같은 해시(이 경우는 md5('1'))는 **서버 응답에 특정한 값이 포함되는지를 확인하려는 수단**입니다.

---

#### 🔹3:

* 이 쿼리는 종종 **결과가 참일 경우 특정 문자열이 응답에 포함**되게 만들고, 이를 통해 참/거짓을 판단합니다.
* 예시 공격 쿼리:

  ```sql
  ' AND (SELECT 1 FROM (SELECT COUNT(*), CONCAT('c4ca4238a0b923820dcc509a6f75849b', FLOOR(RAND()*2)) AS x FROM information_schema.tables GROUP BY x) y) --
  ```
* 작동 방식:

  * `FLOOR(RAND()*2)`는 `0` 또는 `1`을 랜덤하게 만들고, 중복된 `x` 값을 `GROUP BY` 하려고 하여 **"Duplicate entry" 오류**를 발생시킴.
  * 오류 메시지 안에 `CONCAT`된 문자열(`c4ca4238...`)이 포함되면, 공격자는 쿼리의 조건이 **실행되었는지 여부를 판단**할 수 있습니다.
  * 이는 **Blind SQL Injection의 오류 기반(Error-Based)** 기법이며, 일반적으로 응답을 통해 참/거짓을 추론하는 데 사용됩니다.

---

### 🔸 참고

| 항목                   | 설명                                   |
| -------------------- | ------------------------------------ |
| `SELECT` 중첩          | 여러 개의 SELECT 문을 중첩시켜 DB 내부 구조에 접근    |
| `CONCAT()`           | 문자열을 응답에 노출시켜 참/거짓 판별 또는 정보 추출       |
| `COUNT(*)`           | 테이블 존재 여부를 판단하는 데 사용                 |
| `RAND()`             | 랜덤성으로 GROUP BY 오류를 유도 (에러 메시지 기반 공격) |
| `information_schema` | DB 구조(테이블, 컬럼 등)를 알기 위한 정보 수집 시도     |

---

### 🔒 DB Blind SQL Injection


#### 1. **DB 이름 길이 추출**

* **쿼리 예시**:

```sql
length(database()) = 13
```

* **원리**:

  * `length(database())`: 데이터베이스 이름의 길이를 반환
  * 길이가 13이면 **정상 응답** (True), 아니면 **500 오류** (False)
  * 공격자는 길이를 추정하여 **DB 이름의 길이**를 파악

#### 2. **부분 문자열 추출 (DB 이름)**

* **쿼리 예시**:

```sql
substr(database(), 3, 1) = '_'
```

* **원리**:

  * `substr(database(), 3, 1)`: 데이터베이스 이름의 **3번째 문자** 추출
  * `= '_'`: 그 문자가 밑줄(_)인지 확인
  * `substring() 함수`는 주어진 문자열에서 지정된 부분을 추출하는 함수
  * Blind SQL Injection에서는 데이터의 존재나 값의 일부를 추출하는 데 활용
 
#### 3. **컬럼 이름 추출 (정보 스키마 탐색)**

* **쿼리 예시**: `users` 테이블의 첫 번째 컬럼 이름의 첫 문자가 `'u'`인지 확인

```sql
substr((select column_name from information_schema.columns where table_name = 'users' limit 1), 1, 1) = 'u'
```

#### 4. **부분 문자열 추출 (DB 이름)**

* **쿼리 예시**:

```sql
) and (substring(version(), 1, 5) = '3.0.3'#"
```

* **원리**:

  * `substr(database(), 3, 1)`: 데이터베이스 이름의 **3번째 문자** 추출
  * `= '_'`: 그 문자가 밑줄(_)인지 확인
  * `version() 함수`는 데이터베이스 시스템의 버전 정보를 반환하는 함수
---

# 🐈‍⬛ 왜 `#"`로도 성공했나
 
1. **주석(comment) 처리**

   * MySQL 계열에서 `#`는 줄 끝까지의 주석을 시작합니다. (`--`도 주석이지만 `--` 뒤에는 공백이 필요합니다.)
   * 따라서 공격자가 `#`을 삽입하면 그 뒤의 원래 쿼리 문법(예: `);`나 `AND ...`)이 무시됩니다.

2. **문자열 닫기 (quote closing)**

   * 취약한 코드가 사용자 입력을 작은따옴표 `'` 또는 큰따옴표 `"`로 감싸 SQL을 만들면, 공격자는 그 안에서 따옴표를 닫고 악의적 조건을 넣은 뒤 주석으로 잔여를 제거할 수 있습니다.
   * 예: 입력이 `"' OR 1=1#` 처럼 되면, 원래 쿼리의 남은 `");` 같은 구문은 실행되지 않습니다.

3. **따라서 `#"`의 조합이 의미하는 것**

   * 보통 패턴은 `"' OR 1=1#` 또는 `" OR "a"="a"#` 처럼 따옴표로 문자열을 닫고(또는 닫았다고 가장하고) `#`로 뒤를 주석처리한 경우입니다.
   * 만약 원래 코드가 큰따옴표 `"`로 감싼다면 공격자는 `"`로 문자열을 닫고 `#`로 주석을 시작했을 가능성이 큽니다. 그래서 `#"`처럼 보이게 됐을 수 있습니다(문맥에 따라 순서가 바뀌어 보일 수 있음).
  
# 왜 `);`로 닫지 않아도 되는가

* 원래 쿼리의 `);`는 SQL 구문을 문법적으로 닫아주는 역할이지만, 공격자는 **쿼리의 논리 구조를 바꿔 버렸기 때문에** 더 이상 그 닫는 토큰이 필요 없습니다. `#`로 남은 토큰을 주석 처리하면 문법 오류 없이 원하는 조건문이 실행됩니다.
* 즉, 공격자는 “필요한 만큼만” 구문을 조작하고 나머지는 주석으로 없애 버립니다.

---

# MySQL 예시

취약한 서버 코드(취약한 문자열 결합)

```sql
-- 서버에서 이렇게 만들어진다고 가정:
query = "SELECT * FROM users WHERE username = \"" + user_input + "\";";
```

공격자 입력:

```
admin" OR "1"="1# 
```

결합된 쿼리:

```sql
SELECT * FROM users WHERE username = "admin" OR "1"="1#";
-- MySQL은 # 뒤를 주석으로 취급하므로 실제로 실행되는 쿼리는:
-- SELECT * FROM users WHERE username = "admin" OR "1"="1
```

결과: 조건이 항상 참이 되어 인증 우회 가능. 원래 뒤따르던 `";` 또는 `);` 등은 `#` 때문에 무시.

(만약 원래가 작은따옴표 `'`로 감싼 경우엔 `' OR '1'='1#` 처럼 됩니다.)

---

# 🌚 DBMS별 차이

* `#` 주석은 **MySQL**에서 동작.
* `--` 주석은 대부분 DB에서 동작하지만 `--` 다음에 공백이 요구되는 경우가 있음(MySQL도 마찬가지).
* MSSQL(예: SQL Server)은 `--` 또는 `/* ... */`를 사용.
* 따라서 `#`가 먹혔다는 건 대상이 MySQL 계열이거나, 문자 해석 방식이 그와 유사하다는 단서.

# 간단한 테스트 패턴

* 작은따옴표가 사용되는 곳: `' OR '1'='1#`
* 큰따옴표가 사용되는 곳: `" OR "1"="1#`
* `-- ` (공백 포함) 사용도 테스트: `' OR 1=1 -- `

